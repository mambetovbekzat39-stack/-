export class ImageFileDirectory {
    /**
     * Create an ImageFileDirectory.
     * @param {Map} actualizedFields the file directory, mapping tag names to values
     * @param {Map} deferredFields the deferred fields, mapping tag names to async functions
     * @param {Map} deferredArrays the deferred arrays, mapping tag names to DeferredArray objects
     * @param {number} nextIFDByteOffset the byte offset to the next IFD
     */
    constructor(actualizedFields: Map<any, any>, deferredFields: Map<any, any>, deferredArrays: Map<any, any>, nextIFDByteOffset: number);
    actualizedFields: Map<any, any>;
    deferredFields: Map<any, any>;
    deferredFieldsBeingResolved: Map<any, any>;
    deferredArrays: Map<any, any>;
    nextIFDByteOffset: number;
    /**
     * @param {number|string} tagIdentifier The field tag ID or name
     * @returns {boolean} whether the field exists (actualized or deferred)
     */
    hasTag(tagIdentifier: number | string): boolean;
    /**
     * Synchronously retrieves the value for a given tag. If it is deferred, an error is thrown.
     * @param {number|string} tagIdentifier The field tag ID or name
     * @returns the field value, or undefined if it does not exist
     * @throws {Error} If the tag is deferred and requires asynchronous loading
     */
    getValue(tagIdentifier: number | string): any;
    /**
     * Retrieves the value for a given tag. If it is deferred, it will be loaded first.
     * @param {number|string} tagIdentifier The field tag ID or name
     * @returns the field value, or undefined if it does not exist
     */
    loadValue(tagIdentifier: number | string): Promise<any>;
    /**
     * Retrieves the value at a given index for a tag that is an array. If it is deferred, it will be loaded first.
     * @param {number|string} tagIdentifier The field tag ID or name
     * @param {number} index The index within the array
     * @returns the field value at the given index, or undefined if it does not exist
     */
    loadValueIndexed(tagIdentifier: number | string, index: number): Promise<any>;
    /**
     * Parses the GeoTIFF GeoKeyDirectory tag into a structured object.
     * The GeoKeyDirectory is a special TIFF tag that contains geographic metadata
     * in a key-value format as defined by the GeoTIFF specification.
     * @returns {Partial<Record<import('./globals.js').GeoKeyName, *>>|null} Parsed geo key directory
     *     mapping key names to values, or null if not present
     * @throws {Error} If a referenced geo key value cannot be retrieved
     */
    parseGeoKeyDirectory(): Partial<Record<import("./globals.js").GeoKeyName, any>> | null;
    toObject(): {};
}
/**
 * Parser for Image File Directories (IFDs).
 */
export class ImageFileDirectoryParser {
    /**
     * @param {import("./source/basesource.js").BaseSource} source the data source to fetch from
     * @param {boolean} littleEndian the endianness of the file
     * @param {boolean} bigTiff whether the file is a BigTIFF
     * @param {boolean} [eager=false] whether to eagerly fetch deferred fields.
     *                                 When false (default), tags are loaded lazily on-demand.
     *                                 When true, all tags are loaded immediately during parsing.
     */
    constructor(source: import("./source/basesource.js").BaseSource, littleEndian: boolean, bigTiff: boolean, eager?: boolean);
    source: import("./source/basesource.js").BaseSource;
    littleEndian: boolean;
    bigTiff: boolean;
    eager: boolean;
    /**
     * Helper function to retrieve a DataSlice from the source.
     * @param {number} offset Byte offset of the slice
     * @param {number} [length] Length of the slice
     * @returns {Promise<DataSlice>}
     */
    getSlice(offset: number, length?: number): Promise<DataSlice>;
    /**
     * Instructs to parse an image file directory at the given file offset.
     * As there is no way to ensure that a location is indeed the start of an IFD,
     * this function must be called with caution (e.g only using the IFD offsets from
     * the headers or other IFDs).
     * @param {number} offset the offset to parse the IFD at
     * @returns {Promise<ImageFileDirectory>} the parsed IFD
     */
    parseFileDirectoryAt(offset: number): Promise<ImageFileDirectory>;
}
import DataSlice from './dataslice.js';
//# sourceMappingURL=imagefiledirectory.d.ts.map